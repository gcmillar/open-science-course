<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>NCSU GIS 610-003/603: Tools for open geospatial science</title>

<link rel="shortcut icon" href="../img/favicon.png" />

<link href="../layout.css" rel="stylesheet" type="text/css" media="screen">
<link href="../style.css" rel="stylesheet" type="text/css" media="screen">

</head>

<body>

<div id="outercontainer">
<div id="container">

<header>
<div id="header-image">
</div>

<nav>
<ul class="nav">
<li><a href="../index.html">Syllabus</a></li>
<li><a href="../index.html#schedule">Schedule</a></li>
</ul>
</nav>

</header>

<main>
<!-- This is a generated file. Do not edit. -->
<h1 id="command-line-and-python-tools-for-geospatial-work">Command line and Python tools for geospatial work</h1>
<p>This topic is focused on processing geospatial data in command line. Specifically, we will use GDAL and unix-like command line. For Python, we will use IPython as the interpreter. All the tools we will use are open source under various licenses. With many tools, you can use parameters <code>--version</code>, <code>--help</code>, or <code>--license</code> or run <em>man</em> to find out what is the specific license.</p>
<h2 id="gdal">GDAL</h2>
<p>GDAL is a free and open source project under MIT license. GDAL has CLI and and also C and Python APIs and is used broadly by other software as a backend especially for format transformations. GDAL is an OSGeo project.</p>
<h3 id="preparation">Preparation</h3>
<p>Install (command for Ubuntu):</p>
<pre><code>sudo apt install gdal-bin
sudo apt install python-gdal ipython imagemagick</code></pre>
<p>Download data:</p>
<pre><code>wget https://www.grassbook.org/wp-content/uploads/data_extra/o35078g6_NC.tif.gz</code></pre>
<p>Unpack (GZIP format):</p>
<pre><code>gunzip o35078g6_NC.tif.gz</code></pre>
<h3 id="basics">Basics</h3>
<p>Get info:</p>
<pre><code>gdalinfo o35078g6_NC.tif</code></pre>
<p>Get just first part:</p>
<pre><code>gdalinfo o35078g6_NC.tif | head</code></pre>
<p>Get little more:</p>
<pre><code>gdalinfo o35078g6_NC.tif | head -n 50</code></pre>
<p>Browser through all:</p>
<pre><code>gdalinfo o35078g6_NC.tif | less</code></pre>
<p>See if there is some option for getting just the basic info:</p>
<pre><code>man gdalinfo</code></pre>
<p>Disable printing color table and raster attribute table:</p>
<pre><code>gdalinfo -noct -norat o35078g6_NC.tif</code></pre>
<p>Get more data:</p>
<pre><code>wget http://grass.osgeo.org/sampledata/north_carolina/nc_rast_geotiff.tar.gz
wget http://grass.osgeo.org/sampledata/north_carolina/nc_shape.tar.gz</code></pre>
<p>Unpack the data (TAR.GZ format):</p>
<pre><code>tar xvf nc_rast_geotiff.tar.gz
tar xvf nc_shape.tar.gz</code></pre>
<p>Get info:</p>
<pre><code>ogrinfo -so ncshape/lakes.shp lakes</code></pre>
<h3 id="rasterization">Rasterization</h3>
<p>Rasterize the vector:</p>
<pre><code>gdal_rasterize -burn 100 -te 610760 196084 677119 258303 -tr 100 100 -l lakes ncshape/lakes.shp lakes.tif</code></pre>
<p>Convert TIFF to PNG for visualization using ImageMagick):</p>
<pre><code>convert lakes.tif lakes.png</code></pre>
<p>Show PNG using Eye of GNOME:</p>
<pre><code>eog lakes.png</code></pre>
<h3 id="processing-textual-outputs">Processing textual outputs</h3>
<p>In the previous example, we needed the extent of the vector and we manually transfered the values. That would not be feasible if we would need to do it repetitively or in a reproducible way. Any textual output of a command (standard output), can be easily processed in the command line. Sometimes we have to be careful on how likely is the format to change in the future, but for now, we can consider the <em>ogrinfo</em> output to be stable enough.</p>
<p>We start with extracting just the line we are interested in using the <em>grep</em> command:</p>
<pre><code>ogrinfo -so ncshape/lakes.shp lakes | grep Extent:</code></pre>
<p>Now, we need only the numbers from this line. There is couple of different ways how to do it, like using <em>sed</em>, <em>awk</em>. Here, we will use Python, and although regular expressions are a powerful tool we could use, it will enough to just use <em>replace</em> function. We will use packaged called <em>fileinput</em> which takes care of reading from the standard input (and files if needed). Create a file called <code>filter_numbers.py</code> and use the following content:</p>
<pre><code>#!/usr/bin/env python

import fileinput

for line in fileinput.input():
    print(line
          .replace(&quot;Extent: &quot;, &quot;&quot;)
          .replace(&quot;(&quot;, &quot;&quot;)
          .replace(&quot;)&quot;, &quot;&quot;)
          .replace(&quot;,&quot;, &quot;&quot;)
          .replace(&quot;- &quot;, &quot;&quot;)
          )</code></pre>
<p>Now use the Python script file in the command:</p>
<pre><code>ogrinfo -so ncshape/lakes.shp lakes | grep Extent: | python filter_numbers.py</code></pre>
<p>In unix-like systems, we can make any file executable when it makes sense, so we will do it also with our script. It is done using the <em>chmod</em> command with parameter <code>u+x</code> which adds (<code>+</code>) executable permissions (<code>x</code>) to the user who is the file owner (<code>u</code>):</p>
<pre><code>chmod u+x filter_numbers.py</code></pre>
<p>Now we can use the script without specifying Python as the interpreter because that will be taken from the first line of the script which starts with <code>#!</code>. This line is called <em>shebang</em>. However, we need to be explicit about the script being a file by adding <code>./</code> when it is in the current directory to distinguish it from other commands (for safety and organization purposes):</p>
<pre><code>ogrinfo -so ncshape/lakes.shp lakes | grep Extent: | ./filter_numbers.py</code></pre>
<p>At this point we have the numbers separated by spaces and we can get back to the <em>gdal_rasterize</em> command. We need to include these numbers are part of the <em>gdal_rasterize</em> command. This can be done using <code>$()</code> which is for command substitution which places standard output of one command into the given context, in our case command line parameters of <em>gdal_rasterize</em>. See the final command and notice also the slashes at the end of the first two lines which are telling the interpreter that the command continues on the following line:</p>
<pre><code>gdal_rasterize -burn 100 \
    -te $(ogrinfo -so ncshape/lakes.shp lakes | grep Extent: | python filter_numbers.py) \
    -tr 100 100 -l lakes ncshape/lakes.shp lakes.tif</code></pre>
<p>To preserve georeferencing, we can use <em>gdal_translate</em> to convert TIFF to PNG:</p>
<pre><code>gdal_translate -of PNG -scale -co worldfile=yes lakes.tif lakes.png</code></pre>
<p>To get basic information about a file program called <em>file</em> can be used. We use it to confirm that the format translation preserved number of pixels in the raster:</p>
<pre><code>file lakes.tif
file lakes.png</code></pre>
<h3 id="bash-script-with-parameters">Bash script with parameters</h3>
<p>The above conversion, although basic, requires much longer command than the one which used ImageMagic. Therefore, we will create a script to wrap it and allow for simpler syntax when used in the command line. Python would be unnecessarily complicated for this simple task, so we will use Bash which is using the same syntax as the command line we are using. We will name the file <code>tif2png.sh</code>. Although there is a potential for confusion, we don't have to worry if there is a command of the same name because we will need to specify the path or <code>./</code> when calling the command and we also named the file with file extension and that way, it will be clear what command is used. In the following file content, notice the first line (shebang) and also the numbers one and two preceded with a dollar sign. The dollar sign is used to access value of variables and the special variables <code>$1</code> and <code>$2</code> are set to the first and second parameter in the command line.</p>
<pre><code>#!/bin/bash

gdal_translate -of PNG -scale -co worldfile=yes $1 $2</code></pre>
<h3 id="resampling-and-animation">Resampling and animation</h3>
<p>The <em>gdalwarp</em> is a powerful tool for reprojection and other transformations. We will use it for resampling into lower resolution using <code>average</code> method:</p>
<pre><code>gdalwarp -tr 300 300 -r average -co &quot;TFW=YES&quot; -overwrite ncrast/elev_ned_30m.tif srtm_300.tif</code></pre>
<p>Let's do it for couple more resolutions:</p>
<pre><code>gdalwarp -tr 200 200 -r average -co &quot;TFW=YES&quot; -overwrite ncrast/elev_ned_30m.tif srtm_200.tif
gdalwarp -tr 100 100 -r average -co &quot;TFW=YES&quot; -overwrite ncrast/elev_ned_30m.tif srtm_100.tif
gdalwarp -tr 50 50 -r average -co &quot;TFW=YES&quot; -overwrite ncrast/elev_ned_30m.tif srtm_050.tif</code></pre>
<p>Using previously created script, convert the TIFFs to PNGs:</p>
<pre><code>./tif2png.sh srtm_300.tif srtm_300.png
./tif2png.sh srtm_200.tif srtm_200.png
./tif2png.sh srtm_100.tif srtm_100.png
./tif2png.sh srtm_050.tif srtm_050.png</code></pre>
<p>Using ImageMagic, we can add all to one animated GIF:</p>
<pre><code>convert -coalesce -delay 1/1 -resize 500x srtm_*.png srtm.gif</code></pre>
<h3 id="point-buffer-in-python">Point buffer in Python</h3>
<p>For Python, we will use interactive shell called IPython:</p>
<pre><code>ipython</code></pre>
<p>GDAL (and OGR) functionality is part of the <em>osgeo</em> package:</p>
<pre><code>from osgeo import ogr</code></pre>
<p>Creating a point:</p>
<pre><code>point = ogr.Geometry(ogr.wkbPoint25D)
point.AddPoint(610920, 196552, 320)</code></pre>
<p>Simple printing of a point object:</p>
<pre><code>print point</code></pre>
<p>Point as GeoJSON string:</p>
<pre><code>point.ExportToJson()</code></pre>
<p>Creating a buffer around a point:</p>
<pre><code>buffer = point.Buffer(200)</code></pre>
<p>To write the GeoJSON to a file, open a file for writing (<code>'w'</code>):</p>
<pre><code>buffer_file = open(&#39;buffer.json&#39;, &#39;w&#39;)</code></pre>
<p>Write the GeoJSON string to the file:</p>
<pre><code>buffer_file.write(buffer.ExportToJson())</code></pre>
<p>Close the file (so that all changes are written to the disk and the system knows that we finished working with the file):</p>
<pre><code>buffer_file.close()</code></pre>
<p>Now it would be good to review content of that file. This can be easily done in command line using tools such as <em>cat</em>, <em>less</em>, or <em>head</em>. One of the advantages of IPython is that the command line tools are actually available using an exclamation mark at the beginning of the line like in the following example which shows the first 100 characters from the file:</p>
<pre><code>!head -c 100 buffer.json</code></pre>
<h2 id="resources">Resources</h2>
<h3 id="texts">Texts</h3>
<ul>
<li><a href="http://spatial-ecology.net/dokuwiki/doku.php?id=wiki:gdal">GDAL at Spatial Ecology</a> (collection of tutorials)</li>
<li><a href="http://spatial-ecology.net/dokuwiki/doku.php?id=wiki:pk_tools">pktools at Spatial Ecology</a> (collection of tutorials)</li>
<li><a href="https://pcjericks.github.io/py-gdalogr-cookbook/">Python GDAL/OGR Cookbook</a></li>
</ul>
<h3 id="videos">Videos</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=N_dmiQI1s24">An Introduction to GDAL</a> by Robert Simmon (30 mins)</li>
<li><a href="https://www.youtube.com/watch?v=ap5Y-UcLDNA">Simple raster manipulation using GDAL</a> by Simon Marius Mudd (12 mins)</li>
<li><a href="https://www.youtube.com/watch?v=uM8RQIJmfOk">Pragmatic GDAL</a> by Rob Labs (8 mins)</li>
</ul>
<h2 id="assignment">Assignment</h2>
<p>Go through the above instructions and examples. For smooth experience, it is recommended to use NCSU VCL Ubuntu machine, but testing GDAL on your own computer is highly encouraged.</p>
<p>Then take the part which is resampling the rasters and creating and animated GIF and create a Bash script which does this procedure without repeating commands. If possible, include also download of the file and its unpacking of needed so that your result can be reproduced on any computer. Submit this file to Moodle.</p>
<p>You may find these two following things useful. For loop in Bash is:</p>
<pre><code>for FRUIT in apple orange banana
do
    echo $FRUIT
done</code></pre>
<p>A sequence of numbers can be generated using <em>seq</em>:</p>
<pre><code>seq -w 50 50 300</code></pre>
<p>It is worth noting that the subcommand syntax above (<code>$()</code>) can be used also in this context:</p>
<pre><code>for NUM in $(seq -w 50 50 300)
do
    echo $NUM
done</code></pre>

</main>

<footer>

<nav>
<ul>
<li>
    <li><a class="term-changes" href="https://moodle-courses1718.wolfware.ncsu.edu/course/view.php?id=1806">Moodle site</a></li>
    <li><a href="http://help.ncsu.edu/">Computing Help</a></li>
    <li><a href="http://geospatial.ncsu.edu/">GIST Home</a></li>
    <li><a href="http://www.ncsu.edu/policies/prr-disclaimer.php">Disclaimer</a></li>
    <li><a href="http://oit.ncsu.edu/itaccess">Accessibility</a></li>
    <a href="https://github.com/ncsu-geoforall-lab/open-science-course" title="Fork on GitHub" alt="octocat">
        <img src="../img/github_logo.png">
    </a>
</li>
<li title="Copyright and license (not applicable to linked materials)">
    &copy; 2015
    <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA</a>
    <a href="http://geospatial.ncsu.edu/osgeorel/">NCSU GeoForAll Lab</a>
</li>
</ul>
</nav>

</footer>

</div>
</div>

</body>
</html>
